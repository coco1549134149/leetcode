##（1）
给你一个下标从 0 开始的整数数组 nums 和一个整数 value 。在一步操作中，你可以对 nums 中的任一元素加上或减去 value 。
例如，如果 nums = [1,2,3] 且 value = 2 ，你可以选择 nums[0] 减去 value ，得到 nums = [-1,2,3] 。
数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。
例如，[-1,2,3] 的 MEX 是 0 ，而 [1,0,3] 的 MEX 是 2 。
返回在执行上述操作 任意次 后，nums 的最大 MEX 。
可以将 nums 种数字按照对 k 取余后的结果进行分组，同组内的数字可以变成的数字集合都是相同的。用哈希表存储。要最大化数组的 MEX，因此可以从 0 开始遍历直到无法用剩余数字变成当前数字即可。
    int findSmallestInteger(int* nums, int numsSize, int value) {
    int mp[value];
    memset(mp, 0, sizeof(mp)); //赋初值为0
    for(int i = 0; i < numsSize; i++){
        int x = nums[i];
        int v = (x % value + value) % value;
        mp[v]++;
    }
    int count = 0;
    //对于每个整数 mex，检查其对应的余数 mex % value 是否还有剩余次数。如果有，就消耗一次并继续检查下一个整数
    while(mp[count % value] > 0){
        mp[count % value]--;
        count++;
    }
    return count;
}
